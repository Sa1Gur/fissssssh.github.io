[{"content":"引言 有时候我们可能想在接口中开启一个后台任务，就像这样:\npublic class MyController : Controller { private readonly MyDependency _dep; public MyController(MyDependency d) { _dep = d; } public IActionResult MyAction() { Task.Run(() =\u0026gt; _dep.DoHeavyAsyncWork()); return Json(\u0026#34;Your job is started!\u0026#34;); } } 事实上，这段代码很符合语义，接口也能成功返回。 但是其中有一个潜在问题，随着return语句响应本次请求，ASP.NET Core会开始释放本次请求的依赖，比如控制器和控制器依赖的各种服务……，这就会导致Task.Run语句中的所依赖的定义在控制器中的服务会被释放掉，这可能会导致一些未知的问题。这些潜在问题可能会让你的应用程序随时爆炸！\n让后台任务拥有自己的生存期 为了保证后台服务的依赖不随控制器释放而释放，我们需要定义一个新的服务并将其注册为单例服务，因为单例服务永远不会被释放。\n创建一个名为CannonService的类\nCannonService.cs\npublic class CannonService { private readonly ILogger\u0026lt;CannonService\u0026gt; _logger; private readonly IServiceProvider _serviceProvider; public CannonService(ILogger\u0026lt;CannonService\u0026gt; logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public void Fire(Delegate dg, Action\u0026lt;Exception\u0026gt;? exceptionHandler = null) { if (dg == null) { return; } Task.Run(async () =\u0026gt; { // 通过反射获取委托的参数列表 var parameterTypes = dg.Method.GetParameters().Select(x =\u0026gt; x.ParameterType).ToArray(); var parameters = ArrayPool\u0026lt;object\u0026gt;.Shared.Rent(parameterTypes.Length); try { // 创建一个scope using var scope = _serviceProvider.CreateScope(); // 获取委托的参数实例 for (var i = 0; i \u0026lt; parameterTypes.Length; i++) { var t = parameterTypes[i]; parameters[i] = scope.ServiceProvider.GetRequiredService(t); } // 判断委托是是异步还是同步 var returnType = dg.Method.ReturnType; if (returnType.IsAssignableTo(typeof(Task))) { await (Task)dg.DynamicInvoke(parameters.Take(parameterTypes.Length).ToArray())!; } else { dg.DynamicInvoke(parameters.Take(parameterTypes.Length).ToArray()); } } catch (Exception e) { _logger.LogError(e, \u0026#34;Fire boom!\u0026#34;); exceptionHandler?.Invoke(e); } finally { ArrayPool\u0026lt;object\u0026gt;.Shared.Return(parameters, true); } }); } } 将CannonService注册为单例服务 Program.cs\nbuilder.Services.AddSingleton\u0026lt;CannonService\u0026gt;(); 在需要的地方注入该服务并使用\n触发同步方法\n_cannonService.Fire((SomeService someService) =\u0026gt; { someService.From = nameof(CannonService); someService.DoSomething(); }); 触发异步方法\n_cannonService.Fire(async (SomeService someService) =\u0026gt; { someService.From = nameof(CannonService); await Task.Delay(timeout); someService.DoSomething(); }); 示例 SomeService.cs\nnamespace RunTaskInBackground.Demo { public class SomeService : IDisposable { private readonly ILogger\u0026lt;SomeService\u0026gt; _logger; private bool disposedValue; public string From { get; set; } = null!; public SomeService(ILogger\u0026lt;SomeService\u0026gt; logger) { _logger = logger; } public void DoSomething() { CheckIfClosedThrowDisposed(); _logger.LogInformation(\u0026#34;我从{From}来的，我在干活！\u0026#34;, From); } void CheckIfClosedThrowDisposed() { if (disposedValue) throw new ObjectDisposedException(null, \u0026#34;我歇逼了，别叫我！\u0026#34;); } protected virtual void Dispose(bool disposing) { if (!disposedValue) { if (disposing) { if (!string.IsNullOrEmpty(From)) { _logger.LogInformation(\u0026#34;我从{From}来的，我歇逼了！\u0026#34;, From); } else { _logger.LogInformation(\u0026#34;我没有🐎，我歇逼了！\u0026#34;); } } disposedValue = true; } } public void Dispose() { Dispose(disposing: true); GC.SuppressFinalize(this); } } } Program.cs\nusing RunTaskInBackground.Demo; var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddControllers(); // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle builder.Services.AddEndpointsApiExplorer(); builder.Services.AddSwaggerGen(); builder.Services.AddSingleton\u0026lt;CannonService\u0026gt;(); builder.Services.AddScoped\u0026lt;SomeService\u0026gt;(); var app = builder.Build(); // Configure the HTTP request pipeline. if (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } app.UseAuthorization(); app.MapControllers(); app.Run(); HomeController.cs\nusing Microsoft.AspNetCore.Mvc; namespace RunTaskInBackground.Demo.Controllers { [ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class HomeController : ControllerBase { private readonly ILogger\u0026lt;HomeController\u0026gt; _logger; private readonly CannonService _cannonService; private readonly SomeService _someService; public HomeController(ILogger\u0026lt;HomeController\u0026gt; logger, CannonService cannonService, SomeService someService) { _logger = logger; _cannonService = cannonService; _someService = someService; _someService.From = nameof(HomeController); } [HttpGet] [Route(\u0026#34;Async\u0026#34;)] public IActionResult RunAsync(int timeout = 1000) { _cannonService.Fire(async (SomeService someService) =\u0026gt; { someService.From = nameof(CannonService); await Task.Delay(timeout); someService.DoSomething(); }); return Ok(); } [HttpGet] [Route(\u0026#34;AsyncBoom\u0026#34;)] public IActionResult RunAsyncBoom(int timeout = 1000) { _cannonService.Fire(async () =\u0026gt; { await Task.Delay(timeout); _someService.DoSomething(); }); return Ok(); } [HttpGet] [Route(\u0026#34;Sync\u0026#34;)] public IActionResult RunSync() { _cannonService.Fire((SomeService someService) =\u0026gt; { someService.From = nameof(CannonService); someService.DoSomething(); }); return Ok(); } } } 在 swagger 中分别调用 Sync，Async，AsyncBoom 接口，结果如下图所示：\n参考 Anduin Xue.Fire and forget in ASP.NET Core with dependency alive[EB/OL].(2020-10-14)[2022-06-27].https://anduin.aiursoft.com/post/2020/10/14/fire-and-forget-in-aspnet-core-with-dependency-alive 附 完整 Demo 地址 ","permalink":"https://fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/","summary":"引言 有时候我们可能想在接口中开启一个后台任务，就像这样:\npublic class MyController : Controller { private readonly MyDependency _dep; public MyController(MyDependency d) { _dep = d; } public IActionResult MyAction() { Task.Run(() =\u0026gt; _dep.DoHeavyAsyncWork()); return Json(\u0026#34;Your job is started!\u0026#34;); } } 事实上，这段代码很符合语义，接口也能成功返回。 但是其中有一个潜在问题，随着return语句响应本次请求，ASP.NET Core会开始释放本次请求的依赖，比如控制器和控制器依赖的各种服务……，这就会导致Task.Run语句中的所依赖的定义在控制器中的服务会被释放掉，这可能会导致一些未知的问题。这些潜在问题可能会让你的应用程序随时爆炸！\n让后台任务拥有自己的生存期 为了保证后台服务的依赖不随控制器释放而释放，我们需要定义一个新的服务并将其注册为单例服务，因为单例服务永远不会被释放。\n创建一个名为CannonService的类\nCannonService.cs\npublic class CannonService { private readonly ILogger\u0026lt;CannonService\u0026gt; _logger; private readonly IServiceProvider _serviceProvider; public CannonService(ILogger\u0026lt;CannonService\u0026gt; logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public void Fire(Delegate dg, Action\u0026lt;Exception\u0026gt;?","title":"如何在 ASP.NET Core WEB API 中启动后台任务"},{"content":" Anduin Xue let today = new Beginning(); ","permalink":"https://fissssssh.com/links/","summary":" Anduin Xue let today = new Beginning(); ","title":"Links"},{"content":"Create a docker-compose.yml version: \u0026#34;3.9\u0026#34; services: redis-1: image: redis:7.0.2-alpine container_name: redis-1 ports: - \u0026#34;6371:6371\u0026#34; - \u0026#34;16371:16371\u0026#34; volumes: - ./node-1/data:/data - ./node-1/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.11 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-2: image: redis:7.0.2-alpine container_name: redis-2 ports: - \u0026#34;6372:6372\u0026#34; - \u0026#34;16372:16372\u0026#34; volumes: - ./node-2/data:/data - ./node-2/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.12 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-3: image: redis:7.0.2-alpine container_name: redis-3 ports: - \u0026#34;6373:6373\u0026#34; - \u0026#34;16373:16373\u0026#34; volumes: - ./node-3/data:/data - ./node-3/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.13 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-4: image: redis:7.0.2-alpine container_name: redis-4 ports: - \u0026#34;6374:6374\u0026#34; - \u0026#34;16374:16374\u0026#34; volumes: - ./node-4/data:/data - ./node-4/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.14 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-5: image: redis:7.0.2-alpine container_name: redis-5 ports: - \u0026#34;6375:6375\u0026#34; - \u0026#34;16375:16375\u0026#34; volumes: - ./node-5/data:/data - ./node-5/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.15 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-6: image: redis:7.0.2-alpine container_name: redis-6 ports: - \u0026#34;6376:6376\u0026#34; - \u0026#34;16376:16376\u0026#34; volumes: - ./node-6/data:/data - ./node-6/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.16 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-cluster: image: redis:7.0.2-alpine networks: redis: ipv4_address: 172.28.0.17 depends_on: - redis-1 - redis-2 - redis-3 - redis-4 - redis-5 - redis-6 command: - \u0026#34;redis-cli\u0026#34; - \u0026#34;--cluster\u0026#34; - \u0026#34;create\u0026#34; - \u0026#34;172.28.0.11:6371\u0026#34; - \u0026#34;172.28.0.12:6372\u0026#34; - \u0026#34;172.28.0.13:6373\u0026#34; - \u0026#34;172.28.0.14:6374\u0026#34; - \u0026#34;172.28.0.15:6375\u0026#34; - \u0026#34;172.28.0.16:6376\u0026#34; - \u0026#34;--cluster-replicas\u0026#34; - \u0026#34;1\u0026#34; - \u0026#34;--cluster-yes\u0026#34; networks: redis: ipam: config: - subnet: \u0026#34;172.28.0.0/16\u0026#34; There has a container named redis-cluster, the container is for create cluster for redis nodes, if you dont like this, you can enter any redis node container and execute the following command\nredis-cli --cluster create \\ 172.28.0.11:6371 \\ 172.28.0.12:6372 \\ 172.28.0.13:6373 \\ 172.28.0.14:6374 \\ 172.28.0.15:6375 \\ 172.28.0.16:6376 \\ --cluster-replicas 1 --cluster-yes Create config files for every redis node Run the following commands to create config files\nfor port in $(seq 1 6); \\ do \\ mkdir -p ./node-${port}/conf touch ./node-${port}/conf/redis.conf cat \u0026lt;\u0026lt; EOF \u0026gt; ./node-${port}/conf/redis.conf port 637${port} bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip \u0026lt;your_external_ip\u0026gt; cluster-announce-port 637${port} cluster-announce-bus-port 1637${port} appendonly yes EOF done You can change port range if nesscessary\nfor port in $(seq 1 6); \\ ... -port 637${port} +port \u0026lt;port_prefix\u0026gt;${port} ... -cluster-announce-port 637${port} -cluster-announce-bus-port 1637${port} +cluster-announce-port \u0026lt;port_prefix\u0026gt;${port} +cluster-announce-bus-port \u0026lt;cluster_announce_bus_port_prefix\u0026gt;${port} ... done It also need to change docker-compose.yml\nversion: \u0026#34;3.9\u0026#34; services: redis-1: ... ports: - - \u0026#34;6371:6371\u0026#34; - - \u0026#34;16371:16371\u0026#34; + - \u0026#34;\u0026lt;port_prefix\u0026gt;1:\u0026lt;port_prefix\u0026gt;1\u0026#34; + - \u0026#34;\u0026lt;cluster_announce_bus_port_prefix\u0026gt;1:\u0026lt;cluster_announce_bus_port_prefix\u0026gt;1\u0026#34; ... redis-2: ... ports: - - \u0026#34;6372:6372\u0026#34; - - \u0026#34;16372:16372\u0026#34; + - \u0026#34;\u0026lt;port_prefix\u0026gt;:\u0026lt;port_prefix\u0026gt;\u0026#34; + - \u0026#34;\u0026lt;cluster_announce_bus_port_prefix\u0026gt;2:\u0026lt;cluster_announce_bus_port_prefix\u0026gt;2\u0026#34; ... redis-3: ... ports: - - \u0026#34;6373:6373\u0026#34; - - \u0026#34;16373:16373\u0026#34; + - \u0026#34;\u0026lt;port_prefix\u0026gt;3:\u0026lt;port_prefix\u0026gt;3\u0026#34; + - \u0026#34;\u0026lt;cluster_announce_bus_port_prefix\u0026gt;3:\u0026lt;cluster_announce_bus_port_prefix\u0026gt;3\u0026#34; ... redis-4: ... ports: - - \u0026#34;6374:6374\u0026#34; - - \u0026#34;16374:16374\u0026#34; + - \u0026#34;\u0026lt;port_prefix\u0026gt;4:\u0026lt;port_prefix\u0026gt;4\u0026#34; + - \u0026#34;\u0026lt;cluster_announce_bus_port_prefix\u0026gt;4:\u0026lt;cluster_announce_bus_port_prefix\u0026gt;4\u0026#34; ... redis-5: ... ports: - - \u0026#34;6375:6375\u0026#34; - - \u0026#34;16375:16375\u0026#34; + - \u0026#34;\u0026lt;port_prefix\u0026gt;5:\u0026lt;port_prefix\u0026gt;5\u0026#34; + - \u0026#34;\u0026lt;cluster_announce_bus_port_prefix\u0026gt;5:\u0026lt;cluster_announce_bus_port_prefix\u0026gt;5\u0026#34; ... redis-6: ... ports: - - \u0026#34;6376:6376\u0026#34; - - \u0026#34;16376:16376\u0026#34; + - \u0026#34;\u0026lt;port_prefix\u0026gt;6:\u0026lt;port_prefix\u0026gt;6\u0026#34; + - \u0026#34;\u0026lt;cluster_announce_bus_port_prefix\u0026gt;6:\u0026lt;cluster_announce_bus_port_prefix\u0026gt;6\u0026#34; ... redis-cluster: ... command: ... - - \u0026#34;172.28.0.11:6371\u0026#34; - - \u0026#34;172.28.0.12:6372\u0026#34; - - \u0026#34;172.28.0.13:6373\u0026#34; - - \u0026#34;172.28.0.14:6374\u0026#34; - - \u0026#34;172.28.0.15:6375\u0026#34; - - \u0026#34;172.28.0.16:6376\u0026#34; + - \u0026#34;172.28.0.11:\u0026lt;port_prefix\u0026gt;1\u0026#34; + - \u0026#34;172.28.0.12:\u0026lt;port_prefix\u0026gt;2\u0026#34; + - \u0026#34;172.28.0.13:\u0026lt;port_prefix\u0026gt;3\u0026#34; + - \u0026#34;172.28.0.14:\u0026lt;port_prefix\u0026gt;4\u0026#34; + - \u0026#34;172.28.0.15:\u0026lt;port_prefix\u0026gt;5\u0026#34; + - \u0026#34;172.28.0.16:\u0026lt;port_prefix\u0026gt;6\u0026#34; ... Start redis cluster Just run command docker-compose up -d.\n","permalink":"https://fissssssh.com/posts/create-redis-cluster-by-docker-compose/","summary":"Create a docker-compose.yml version: \u0026#34;3.9\u0026#34; services: redis-1: image: redis:7.0.2-alpine container_name: redis-1 ports: - \u0026#34;6371:6371\u0026#34; - \u0026#34;16371:16371\u0026#34; volumes: - ./node-1/data:/data - ./node-1/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.11 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-2: image: redis:7.0.2-alpine container_name: redis-2 ports: - \u0026#34;6372:6372\u0026#34; - \u0026#34;16372:16372\u0026#34; volumes: - ./node-2/data:/data - ./node-2/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.28.0.12 command: - \u0026#34;redis-server\u0026#34; - \u0026#34;/etc/redis/redis.conf\u0026#34; redis-3: image: redis:7.0.2-alpine container_name: redis-3 ports: - \u0026#34;6373:6373\u0026#34; - \u0026#34;16373:16373\u0026#34; volumes: - ./node-3/data:/data - ./node-3/conf/redis.conf:/etc/redis/redis.conf networks: redis: ipv4_address: 172.","title":"Create Redis Cluster by Docker Compose"},{"content":"问题描述 近日我使用 hugo 构建了我的博客，并通过 Github Action 将其发布在 Github Pages 上，刚开始还是很美好的，但是过一短时间以后打开页面发现样式全无，使用浏览器的开发者工具查看资源获取没有问题，但是在控制台却出现了这样一句话：\nFailed to find a valid digest in the \u0026#39;integrity\u0026#39; attribute for resource \u0026#39;***\u0026#39; with computed SHA-256 integrity \u0026#39;***\u0026#39;. The resource has been blocked. 寻找原因 我在 MDN 上寻找到了关于 integrity 的定义，大概描述就是这是一个签名，浏览器获取到相应资源后会用相同的方法计算一个签名，只有签名相同时才会加载对应的资源，如果两个签名不一致则是文件完整性被破坏（文件发生了改变）。\n问题来了，整个发布过程是由 Github Action 全自动操作的，没有人为干预，文件为何会无缘无故改变呢？\n答案是 Cloudflare。 Cloudflare 中默认会开启静态资源的缓存来提高网站的加载速度，可是为什么缓存会改变文件呢？缓存并不会改变文件，在 Cloudflare 的 Speed \u0026gt; Optimization 中有一个叫 Auto Minify 的选项，描述如下：\nReduce the file size of source code on your website.\nNote: Purge cache to have your change take effect immediately.\n这句话翻译过来就是 减小网站源代码文件体积的大小 ，同时该选项有 3 个子选项：\nJavaScript CSS HTML 默认都是选中状态，即默认会压缩我们的 js，css 和 html 文件。\n解决问题 因为我们网站是 css 文件的签名验证出现了问题，因此我们取消 Auto Minify 下面的 Css 选项，然后在Caching \u0026gt; Configuration 中点击 Purge Cache 清除缓存，回到网站使用 ctrl + F5 强制刷新网页，问题解决。\n其他解决方案 我使用的是 PaperMod 主题，可以将主题文件 layouts/partials/head.html 中 css 引用部分的 integrity 属性去除，同样可以解决，但我觉得主题毕竟是第三方库，在非必要情况下不要修改第三方库。\n- \u0026lt;link crossorigin=\u0026#34;anonymous\u0026#34; href=\u0026#34;{{ $stylesheet.RelPermalink }}\u0026#34; integrity=\u0026#34;{{ $stylesheet.Data.Integrity }}\u0026#34; rel=\u0026#34;preload stylesheet\u0026#34; as=\u0026#34;style\u0026#34;\u0026gt; + \u0026lt;link crossorigin=\u0026#34;anonymous\u0026#34; href=\u0026#34;{{ $stylesheet.RelPermalink }}\u0026#34; rel=\u0026#34;preload stylesheet\u0026#34; as=\u0026#34;style\u0026#34;\u0026gt; 结束语 遇到困难仔细分析，终会迎刃而解。\n","permalink":"https://fissssssh.com/posts/css-integrity-error-when-load-hugo-publish/","summary":"问题描述 近日我使用 hugo 构建了我的博客，并通过 Github Action 将其发布在 Github Pages 上，刚开始还是很美好的，但是过一短时间以后打开页面发现样式全无，使用浏览器的开发者工具查看资源获取没有问题，但是在控制台却出现了这样一句话：\nFailed to find a valid digest in the \u0026#39;integrity\u0026#39; attribute for resource \u0026#39;***\u0026#39; with computed SHA-256 integrity \u0026#39;***\u0026#39;. The resource has been blocked. 寻找原因 我在 MDN 上寻找到了关于 integrity 的定义，大概描述就是这是一个签名，浏览器获取到相应资源后会用相同的方法计算一个签名，只有签名相同时才会加载对应的资源，如果两个签名不一致则是文件完整性被破坏（文件发生了改变）。\n问题来了，整个发布过程是由 Github Action 全自动操作的，没有人为干预，文件为何会无缘无故改变呢？\n答案是 Cloudflare。 Cloudflare 中默认会开启静态资源的缓存来提高网站的加载速度，可是为什么缓存会改变文件呢？缓存并不会改变文件，在 Cloudflare 的 Speed \u0026gt; Optimization 中有一个叫 Auto Minify 的选项，描述如下：\nReduce the file size of source code on your website.\nNote: Purge cache to have your change take effect immediately.","title":"Css Integrity Error When Load Hugo Publish"},{"content":"Introduction VSCode(Visual Studio Code) is a code editor redefined and optimized for building and debugging modern web and cloud applications.\nCode Snippets is a piece of code, the editor will auto complete a specific code when developer type some specific prefixes.\nCustom Code Snippets VSCode has many built-in code snippets, so I won\u0026rsquo;t go into details here, but mainly talk about how to customize code snippets.\nThere are two types of code snippets, one is global and the other is workspace, the difference between them is that the scope and storage location.\nglobal code snippets\nAny file opened by vscode can take effect and is stored in the installation directory.\nworkspace code snippets\nOnly the files in the workspace can take effect and are stored in the .vscode directory of the workspace.\nHow to create custom code snippets? Click File \u0026gt; Preferences \u0026gt; Configure User Snippets.\nClick New Global Snippets file... or New Snippets file for '\u0026lt;your_workspce_name\u0026gt;'....\nCode snippets store as json, Each snippet is defined under a snippet name and has a scope, prefix, body and description:\nscope: A comma separated ids of the languages where the snippet is applicable. If scope is left empty or omitted, the snippet gets applied to all languages prefix: It\u0026rsquo;s used to trigger the snippet and the body will be expanded and inserted. Possible variables are: $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders body: The code description: The description of this code snippet Example:\n{ \u0026#34;scope\u0026#34;: \u0026#34;c\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;smain\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;#include \u0026lt;stdio.h\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;int main(void)\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;\\t${1:/* Code here */}\u0026#34;, \u0026#34;\\treturn 0;\u0026#34;, \u0026#34;}\u0026#34; ] } A code snippets can store many code snippets, the root is a Object, a property corresponds to a code snippet\nExample:\n{ \u0026#34;Simple main\u0026#34;: { \u0026#34;scope\u0026#34;: \u0026#34;c\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;smain\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;#include \u0026lt;stdio.h\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;int main(void)\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;\\t${1:/* Code here */}\u0026#34;, \u0026#34;\\treturn 0;\u0026#34;, \u0026#34;}\u0026#34; ] }, \u0026#34;Simple main c++\u0026#34;: { \u0026#34;scope\u0026#34;: \u0026#34;cpp\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;smainpp\u0026#34;, \u0026#34;body\u0026#34;: [ \u0026#34;#include \u0026lt;iostream\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;using namespace std;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;int main()\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;\\t${1:/* Code here */}\u0026#34;, \u0026#34;\\treturn 0;\u0026#34;, \u0026#34;}\u0026#34; ] } } Use code snippets\nRemarks Reasonable use of code snippets can greatly improve our coding efficiency\n","permalink":"https://fissssssh.com/posts/code-snippets.in-vscode/","summary":"Introduction VSCode(Visual Studio Code) is a code editor redefined and optimized for building and debugging modern web and cloud applications.\nCode Snippets is a piece of code, the editor will auto complete a specific code when developer type some specific prefixes.\nCustom Code Snippets VSCode has many built-in code snippets, so I won\u0026rsquo;t go into details here, but mainly talk about how to customize code snippets.\nThere are two types of code snippets, one is global and the other is workspace, the difference between them is that the scope and storage location.","title":"Code Snippets in VSCode"},{"content":"以下是我本人平时喜欢用的软件，排名不分先后\n名称 描述 类型 7-Zip 压缩软件 desktop Fiddler HTTP 抓包工具 desktop Git 代码管理软件 cli,desktop Google Chrome 顶级浏览器 desktop MPC-HC 视频播放器 desktop MSI Afterburner 性能监视超频软件 desktop MacType Windows 字体渲染 desktop OBS Studio 推流工具 desktop PowerToys Windows 小工具集合 desktop Sourcetree 代码管理软件 desktop ToDesk 远程桌面工具 desktop Virtual Audio Cable 音频管理软件 desktop Visual Studio Code 吃饭的家伙 desktop Visual Studio 吃饭的家伙 desktop Voicemetter Banana 音频管理软件 desktop WinHex 文件查看工具 desktop WinSCP 文件复制工具 desktop WinaeroTweaker Windows 工具 desktop WireShark 网络抓包工具 desktop Wiztree 磁盘分析工具 desktop dnSpy .NET 反编译调试软件 desktop docker 容器环境 cli, desktop ffmpeg 流媒体处理工具 cli hugo 静态页面构建工具 cli 迅雷 下载工具 desktop ","permalink":"https://fissssssh.com/posts/recommended-software/","summary":"以下是我本人平时喜欢用的软件，排名不分先后\n名称 描述 类型 7-Zip 压缩软件 desktop Fiddler HTTP 抓包工具 desktop Git 代码管理软件 cli,desktop Google Chrome 顶级浏览器 desktop MPC-HC 视频播放器 desktop MSI Afterburner 性能监视超频软件 desktop MacType Windows 字体渲染 desktop OBS Studio 推流工具 desktop PowerToys Windows 小工具集合 desktop Sourcetree 代码管理软件 desktop ToDesk 远程桌面工具 desktop Virtual Audio Cable 音频管理软件 desktop Visual Studio Code 吃饭的家伙 desktop Visual Studio 吃饭的家伙 desktop Voicemetter Banana 音频管理软件 desktop WinHex 文件查看工具 desktop WinSCP 文件复制工具 desktop WinaeroTweaker Windows 工具 desktop WireShark 网络抓包工具 desktop Wiztree 磁盘分析工具 desktop dnSpy .","title":"软件推荐"}]