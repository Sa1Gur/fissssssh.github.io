<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>ASP.NET Core on fissssssh</title><link>https://fissssssh.com/tags/asp.net-core/</link><description>Recent content in ASP.NET Core on fissssssh</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 27 Jun 2022 20:30:49 +0800</lastBuildDate><atom:link href="https://fissssssh.com/tags/asp.net-core/index.xml" rel="self" type="application/rss+xml"/><item><title>如何在 ASP.NET Core WEB API 中启动后台任务</title><link>https://fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</link><pubDate>Mon, 27 Jun 2022 20:30:49 +0800</pubDate><guid>https://fissssssh.com/posts/how-to-start-backgroud-task-in-asp_net_core_webapi/</guid><description>引言 有时候我们可能想在接口中开启一个后台任务，就像这样:
public class MyController : Controller { private readonly MyDependency _dep; public MyController(MyDependency d) { _dep = d; } public IActionResult MyAction() { Task.Run(() =&amp;gt; _dep.DoHeavyAsyncWork()); return Json(&amp;#34;Your job is started!&amp;#34;); } } 事实上，这段代码很符合语义，接口也能成功返回。 但是其中有一个潜在问题，随着return语句响应本次请求，ASP.NET Core会开始释放本次请求的依赖，比如控制器和控制器依赖的各种服务……，这就会导致Task.Run语句中的所依赖的定义在控制器中的服务会被释放掉，这可能会导致一些未知的问题。这些潜在问题可能会让你的应用程序随时爆炸！
让后台任务拥有自己的生存期 为了保证后台服务的依赖不随控制器释放而释放，我们需要定义一个新的服务并将其注册为单例服务，因为单例服务永远不会被释放。
创建一个名为CannonService的类
CannonService.cs
public class CannonService { private readonly ILogger&amp;lt;CannonService&amp;gt; _logger; private readonly IServiceProvider _serviceProvider; public CannonService(ILogger&amp;lt;CannonService&amp;gt; logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; } public void Fire(Delegate dg, Action&amp;lt;Exception&amp;gt;?</description></item></channel></rss>